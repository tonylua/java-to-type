{"version":3,"file":"j2type.js","sources":["../src/utils/type.ts","../src/utils/text.ts","../src/parsers/ServiceParser.ts","../src/parsers/ConstantParser.ts","../src/utils/constants.ts","../src/parsers/BaseParser.ts","../src/parsers/EnumParser.ts","../src/parsers/PojoParser.ts","../src/utils/file.ts","../src/index.ts"],"sourcesContent":["import type { ParserMeta } from '../types/Parser'\r\nconst path = require('path')\r\n\r\nconst TypeMap = {\r\n  'boolean': 'Boolean',            \r\n  'Boolean': 'Boolean',            \r\n  'char': 'String',                \r\n  'Character': 'String',           \r\n  'char[]': 'String',              \r\n  'String': 'String',              \r\n  'Date': 'String',                \r\n  'LocalDate': 'String',           \r\n  'LocalDateTime': 'String',       \r\n  'LocalTime': 'String',           \r\n  'ZonedDateTime': 'String',       \r\n  'OffsetDateTime': 'String',      \r\n  'UUID': 'String',                \r\n  'byte': 'Number',                \r\n  'Byte': 'Number',                \r\n  'short': 'Number',               \r\n  'Short': 'Number',               \r\n  'int': 'Number',                 \r\n  'Integer': 'Number',             \r\n  'long': 'Number',                \r\n  'Long': 'Number',                \r\n  'float': 'Number',               \r\n  'Float': 'Number',               \r\n  'double': 'Number',              \r\n  'Double': 'Number',              \r\n  'Instant': 'Number',             \r\n  'BigDecimal': 'Number',          \r\n  'BigInteger': 'BigInt',          \r\n  'Optional': 'null',              \r\n  'void': 'undefined',             \r\n}\r\n\r\n// https://github.com/microsoft/TypeScript/issues/36132#issuecomment-573141594\r\nexport const getJSType = function getJSType(\r\n  javaType: string,\r\n  isTypescript = false,\r\n) {\r\n  // const arrRe: RegExp = /(?:\\w*)List<(?<itemType>\\w+)>/g;\r\n  const arrRe: RegExp = /(?:\\w*)List<(\\w+)>/g\r\n  if (arrRe.test(javaType)) {\r\n    const m = new RegExp(arrRe).exec(javaType)\r\n    // return `${getJSType(m.groups.itemType)}[]`;\r\n    return `${getJSType(m[1], isTypescript)}[]`\r\n  }\r\n  const mapped = TypeMap[javaType] || TypeMap[javaType.toLowerCase()]\r\n  if (mapped) return isTypescript ? mapped.toLowerCase() : mapped\r\n  return javaType\r\n}\r\n\r\nexport function getOrImportType(javaType: string, parserMeta: ParserMeta) {\r\n  const serviceMeta = parserMeta?.serviceMeta\r\n  let t = getJSType(javaType, parserMeta?.outputTS)\r\n\r\n  const arrMatch = /^(.*?)(\\[\\])+$/.exec(t)\r\n  if (arrMatch) return getOrImportType(arrMatch[1], serviceMeta) + arrMatch[2]\r\n\r\n  const genericMatch = /^(.*?)<(.*?)>$/.exec(t)\r\n  if (genericMatch) {\r\n    const types = genericMatch[2]\r\n      .split(/\\s*\\,\\s*/)\r\n      .map(t => getOrImportType(t, serviceMeta))\r\n      .join(', ')\r\n    return `${genericMatch[1]}<${types}>`\r\n  }\r\n\r\n  if (t in global.dtsCache) {\r\n    const javaDir = path.dirname(global.dtsCache[t])\r\n    const metaKey = Object.keys(serviceMeta).find(k => k === javaDir)\r\n    if (metaKey) {\r\n      const dtsPath = serviceMeta[metaKey].replace(/\\.d\\.ts$/, '')\r\n      t = `import('${dtsPath}').${t}`\r\n    }\r\n  }\r\n\r\n  return t\r\n}\r\n","export const replaceQuote = (str: string, replaceTo: string = \"\") =>\r\n  str.replace(/^\"/, replaceTo).replace(/\"$/, replaceTo);\r\n\r\nexport const formatParagraph = (str: string) =>\r\n  str.replace(/\\n\\s*\\n/gm, \"\\n\").trim();\r\n","import { getOrImportType } from '../utils/type'\r\nimport { formatParagraph } from '../utils/text'\r\nimport type {\r\n  ParserMeta,\r\n  ParserContructor,\r\n  ControllerType,\r\n  ServiceType,\r\n  ServiceParamType,\r\n  ParseResult,\r\n} from '../types/Parser'\r\nimport BaseParser from './BaseParser'\r\n\r\nconst ServiceParser: ParserContructor = class ServiceParser extends BaseParser {\r\n  static CONTROLLER_RE =\r\n    /@RestController\\s*\\n\\s*@RequestMapping\\(\\\"(?<url>[\\w\\/_-{}:]+?)\\\"\\)[\\s\\S]*?\\npublic\\s+class\\s+(?<name>\\w+?)Controller\\s+/g\r\n\r\n  static SERVICE_RE =\r\n    /(\\/\\*{2}\\n\\s+\\*\\s+(?<desc>[^@\\s]*?)\\n(?:[\\s\\S]+?))?@(?:(?<method>Get|Post|Update|Put|Delete)?)Mapping\\(\\s*(?:value\\s*=\\s*)?\"(?<url>[\\w\\/_-{}:]+?)\\\".*?\\)(?:[\\s\\S]+?)public\\s+(?<res>[\\w<>_[\\](,\\s)]+?)\\s+(?<name>[\\w_-]+?)\\((?<params_str>[\\s\\S]*)\\)?\\s*{/gi\r\n\r\n  static PARAM_RE =\r\n    /(?<param_annotation>@.*?\\s)?(?<param_type>[\\w<>_[\\](,\\s)]+?)\\s+(?<param_name>\\w+)(?:,\\s*)?/g\r\n\r\n  static match(code: string) {\r\n    const { CONTROLLER_RE, SERVICE_RE } = ServiceParser\r\n    return (\r\n      new RegExp(CONTROLLER_RE).test(code) && new RegExp(SERVICE_RE).test(code)\r\n    )\r\n  }\r\n\r\n  private controller: ControllerType\r\n  private services: ServiceType[]\r\n\r\n  constructor(javaCode: string, javaPath: string, meta?: ParserMeta) {\r\n    super(javaCode, javaPath, meta)\r\n    this._getController()\r\n    this._getServices()\r\n    return this\r\n  }\r\n\r\n  private _getController() {\r\n    const match = new RegExp(ServiceParser.CONTROLLER_RE).exec(this.javaCode)\r\n    if (!match) throw new Error('invalid controller')\r\n    // https://github.com/microsoft/TypeScript/issues/36132#issuecomment-573141594\r\n    this.controller = { url: match[1], name: match[2] } // pick(match.groups, 'url', 'name');\r\n  }\r\n\r\n  private _getServices() {\r\n    const services: ServiceType[] = []\r\n    const sRe = new RegExp(ServiceParser.SERVICE_RE)\r\n    let serviceMatch: RegExpMatchArray\r\n    while ((serviceMatch = sRe.exec(this.javaCode)) !== null) {\r\n      // const {params_str} = serviceMatch.groups;\r\n      // console.log(Array.from(serviceMatch))\r\n      const params_str = serviceMatch[7]\r\n      const params: ServiceParamType[] = []\r\n      const pRe = new RegExp(ServiceParser.PARAM_RE)\r\n      let paramMatch: RegExpMatchArray\r\n      const paramStr = (params_str || '')\r\n        .replace(/[\\n\\r]/g, '')\r\n        .replace(/\\s+/g, ' ')\r\n      // console.log(333, params_str, paramStr)\r\n      while ((paramMatch = pRe.exec(paramStr)) !== null) {\r\n        // const p: ServiceParamType = pick(paramMatch.groups,\r\n        //   'param_type', 'param_name', 'param_annotation');\r\n        const p: ServiceParamType = {\r\n          param_annotation: paramMatch[1],\r\n          param_type: paramMatch[2],\r\n          param_name: paramMatch[3],\r\n        }\r\n        params.push(p)\r\n      }\r\n      const hasDesc = /\\/\\*\\*/.test(serviceMatch[1])\r\n      const s: ServiceType = {\r\n        params,\r\n        // ...pick(serviceMatch.groups, 'desc', 'method', 'url', 'res', 'name')\r\n        desc: hasDesc ? serviceMatch[2] : '',\r\n        method: serviceMatch[3],\r\n        url: serviceMatch[4],\r\n        res: serviceMatch[5],\r\n        name: serviceMatch[6],\r\n      }\r\n      // console.log(Array.prototype.slice.call(serviceMatch, 0, 7), s)\r\n      services.push(s)\r\n    }\r\n    this.services = services\r\n  }\r\n\r\n  private _renderServices(service: ServiceType) {\r\n    const url = `${this.controller.url}${service.url}`.replace(/\\/+/g, '/')\r\n    const reqUrl = service.params.reduce(\r\n      (acc, param) => {\r\n        const { param_name, param_annotation: pa } = param\r\n        const placeholder = `{${param_name}}`\r\n        if (pa?.includes('PathVariable') && acc.includes(placeholder)) {\r\n          acc = acc.replace(placeholder, `$${placeholder}`)\r\n        }\r\n        return acc\r\n      },\r\n      '`' + (this.meta?.apiPrefix || '') + url + '`',\r\n    )\r\n    const funcName = url\r\n      .replace(/\\/{\\w+?}/g, '') // placeholder\r\n      .replace(/\\/(\\w)/g, (_, p1) => p1.toUpperCase())\r\n      .replace(/^\\w/, m => m.toLowerCase())\r\n    const jsdocParams = service.params\r\n      .map(param => {\r\n        const { param_type: pt, param_name: pn, param_annotation: pa } = param\r\n        const isHeader = pa?.includes('RequestHeader')\r\n        const isOptional = !pa || !pa.includes('@NotNull')\r\n        const pName = isHeader ? `headers.${pn}` : pn\r\n        const name = isOptional ? ` [${pName}]` : ` ${pName}`\r\n        return `* @param {${getOrImportType(pt, this.meta)}} ${name}`.trim()\r\n      })\r\n      .join('\\n ')\r\n      .trim()\r\n    const mapParams = (param: ServiceParamType) => {\r\n      const { param_name: pn, param_annotation: pa } = param\r\n      const isHeader = pa?.includes('RequestHeader')\r\n      return isHeader ? null : pn\r\n    }\r\n    const funcArgs = service.params.map(mapParams).filter(Boolean).join(', ')\r\n    const bodyOrParams = service.params\r\n      .filter(({ param_annotation: pa }) => !pa || !pa.includes('PathVariable'))\r\n      .map(mapParams)\r\n      .filter(Boolean)\r\n      .map(param =>\r\n        this.javaCode.includes('ResponseBody') ? `...${param}` : param,\r\n      )\r\n    // console.log(service.name, service.method)\r\n\r\n    let mtd = service.method.toLowerCase()\r\n    const paramsKey = /(post|put|patch|delete)/.test(mtd) ? 'body' : 'params'\r\n    const data = bodyOrParams.length\r\n      ? `${paramsKey}: {\r\n      ${bodyOrParams.join(',\\n      ')}\r\n    }`\r\n      : ''\r\n\r\n    return `/** ${service.desc} ${funcName}\r\n * @url ${url}\r\n * @method ${mtd.toUpperCase()}\r\n ${jsdocParams}\r\n * @return {Promise<${getOrImportType(service.res, this.meta)}>}\\n */\\n\r\nexport function ${funcName} (${funcArgs}) {\r\n  return ${this.meta.jsDocServiceRequestInstanceName}({\r\n    url: ${reqUrl},\r\n    method: '${mtd}',\r\n    ${data}\r\n  })\r\n}\r\n  `\r\n  }\r\n\r\n  private _getJSDoc() {\r\n    const cont = formatParagraph(\r\n      this.services.map(this._renderServices.bind(this)).join('\\n').trim(),\r\n    )\r\n    return `${this.meta.jsDocServiceTopImport}\\n\\n${cont}`\r\n  }\r\n\r\n  parse() {\r\n    const rtn: ParseResult = {\r\n      javaPath: this.javaPath,\r\n      result: null,\r\n    }\r\n    // TODO ts\r\n    if (this.meta.outputTS) \r\n      throw new Error('ServiceParser with outputTS not support now')\r\n\r\n    rtn.result = this._getJSDoc()\r\n\r\n    return rtn\r\n  }\r\n}\r\n\r\nexport default ServiceParser\r\n","import { getJSType } from '../utils/type'\r\nimport { formatParagraph, replaceQuote } from '../utils/text'\r\nimport type {\r\n  ParserMeta,\r\n  ParserContructor,\r\n  ParseResult,\r\n  EnumProperty,\r\n} from '../types/Parser'\r\nimport BaseParser from './BaseParser'\r\n\r\n// eslint-disable-next-line max-len\r\nconst ConstantParser: ParserContructor = class ConstantParser extends BaseParser {\r\n  static ENUM_RE = /public\\s+class\\s+(?<enum_name>\\w+)/g\r\n\r\n  static PROPERTY_RE =\r\n    /(?:\\s*\\/\\*{2}\\n\\s*\\*\\s+([^@\\s]+?)\\n[\\s\\S]+?)?public\\sstatic\\sfinal\\s([\\w<>[\\]]+)\\s+([\\w_]+)\\s*=\\s*((\"|[^\\s$])+);?/g\r\n\r\n  static match(code: string) {\r\n    const { ENUM_RE, PROPERTY_RE } = ConstantParser\r\n    return new RegExp(ENUM_RE).test(code) && new RegExp(PROPERTY_RE).test(code)\r\n  }\r\n\r\n  private enumName: string\r\n  private properties: EnumProperty[]\r\n\r\n  constructor(javaCode: string, javaPath: string, meta?: ParserMeta) {\r\n    super(javaCode, javaPath, meta)\r\n    this._getEnumName()\r\n    this._getProperties()\r\n    return this\r\n  }\r\n\r\n  private _getEnumName() {\r\n    const cRe = new RegExp(ConstantParser.ENUM_RE)\r\n    const classMatch: RegExpMatchArray = cRe.exec(this.javaCode)\r\n    this.enumName = classMatch[1] // classMatch?.groups?.enum_name;\r\n  }\r\n\r\n  private _getProperties() {\r\n    const properties: EnumProperty[] = []\r\n    const pRe = new RegExp(ConstantParser.PROPERTY_RE)\r\n    let propertyMatch: RegExpMatchArray\r\n    while ((propertyMatch = pRe.exec(this.javaCode)) !== null) {\r\n      const p: EnumProperty = {\r\n        desc: propertyMatch[1],\r\n        type: propertyMatch[2],\r\n        key: propertyMatch[3],\r\n        value: propertyMatch[4],\r\n      }\r\n      properties.push(p)\r\n    }\r\n    this.properties = properties\r\n  }\r\n\r\n  private _getJSDocWithTS() {\r\n    if (!this.properties.length) return ''\r\n    const enumType = getJSType(this.properties[0].type, this.meta.outputTS)\r\n    let result = new RegExp(ConstantParser.PROPERTY_RE).test(this.javaCode)\r\n      ? this.properties\r\n          .map((prop, propIdx) => {\r\n            const { desc, key, value } = prop\r\n            const pVlu = value ? ` = ${replaceQuote(value, `'`)}` : ``\r\n            const pDesc = desc ? `// ${replaceQuote(desc)}` : ``\r\n            return '  ' + `${key}${pVlu}, ${pDesc}`.trim()\r\n          })\r\n          .join('\\n')\r\n          .trim()\r\n      : '/*TODO no property*/'\r\n    result = `export enum ${this.enumName} {\\n  ${result}\\n}\\n`\r\n    global.dtsCache[this.enumName] = this.javaPath\r\n    return formatParagraph(result)\r\n  }\r\n\r\n  private _getJSDoc() {\r\n    if (!this.properties.length) return ''\r\n    const enumType = getJSType(this.properties[0].type)\r\n    let result = new RegExp(ConstantParser.PROPERTY_RE).test(this.javaCode)\r\n      ? this.properties\r\n          .map((prop, propIdx) => {\r\n            const { desc, key, value } = prop\r\n            const pVlu = value\r\n              ? `: ${replaceQuote(value, `'`)}`\r\n              : `: ${propIdx}`\r\n            const pDesc = desc ? `// ${replaceQuote(desc)}` : ``\r\n            return '  ' + `${key}${pVlu}, ${pDesc}`.trim()\r\n          })\r\n          .join('\\n')\r\n          .trim()\r\n      : '* @todo no property'\r\n    result = `export const ${this.enumName} = {\\n  ${result}\\n}\\n`\r\n    result = `/**\\n * @readonly\\n * @enum {${enumType}}\\n */\\n${result}`\r\n    return formatParagraph(result)\r\n  }\r\n\r\n  parse() {\r\n    const rtn: ParseResult = {\r\n      javaPath: this.javaPath,\r\n      result: null,\r\n    }\r\n\r\n    rtn.result = this.meta.outputTS\r\n      ? this._getJSDocWithTS()\r\n      : this._getJSDoc()\r\n\r\n    return rtn\r\n  }\r\n}\r\n\r\nexport default ConstantParser\r\n","import type {ParserMeta} from \"../types/Parser\";\r\n\r\nexport const DefaultParserMeta: ParserMeta = {\r\n  jsDocServiceRequestInstanceName: 'request',\r\n  jsDocServiceTopImport: `import request from '@/utils/request'`,\r\n}\r\n","import { DefaultParserMeta } from '../utils/constants'\r\nimport type {\r\n  IParser,\r\n  ParserMeta,\r\n  ParseResult,\r\n} from '../types/Parser'\r\n\r\nabstract class BaseParser implements IParser {\r\n  protected javaCode: string\r\n  protected javaPath: string\r\n  protected meta: ParserMeta\r\n\r\n  constructor(javaCode: string, javaPath: string, meta?: ParserMeta) {\r\n    this.javaCode = javaCode\r\n    this.javaPath = javaPath\r\n    this.meta = {\r\n      ...DefaultParserMeta,\r\n      ...meta,\r\n    }\r\n    return this\r\n  }\r\n\r\n  abstract parse(): ParseResult\r\n}\r\n\r\nexport default BaseParser\r\n","import { getJSType } from '../utils/type'\r\nimport { formatParagraph, replaceQuote } from '../utils/text'\r\nimport type {\r\n  ParserMeta,\r\n  ParserContructor,\r\n  ParseResult,\r\n  EnumProperty,\r\n} from '../types/Parser'\r\nimport BaseParser from './BaseParser'\r\n\r\nconst EnumParser: ParserContructor = class EnumParser extends BaseParser {\r\n  static INTERFACE_ENUMS = /(?<=public\\sinterface)[\\s\\S]+?enum\\s+(?<enum_name>\\w+)/gm\r\n\r\n  static ENUM_RE = /public\\s+(?:interface|enum)\\s+(?<enum_name>\\w+)/g\r\n\r\n  static PROPERTY_RE =\r\n    /^\\s+(?<key>[a-zA-Z_]+?)(?:\\((?<value>\\S+?)\\s*(?:,\\s*(?<desc>.+?))?\\))?[,;]/gm \r\n\r\n  static match(code: string) {\r\n    const { ENUM_RE, PROPERTY_RE } = EnumParser\r\n    return new RegExp(ENUM_RE).test(code) && new RegExp(PROPERTY_RE).test(code)\r\n  }\r\n\r\n  private enumNames: string[]\r\n  private properties: Record<string, EnumProperty[]>\r\n\r\n  constructor(javaCode: string, javaPath: string, meta?: ParserMeta) {\r\n    super(javaCode, javaPath, meta)\r\n    this._getEnumNames()\r\n    this._getProperties()\r\n    return this\r\n  }\r\n\r\n  private _getEnumNames() {\r\n    if (EnumParser.INTERFACE_ENUMS.test(this.javaCode)) {\r\n      const iRe = new RegExp(/enum\\s+(?<enum_name>\\w+)/gm);\r\n      let match, names = [];\r\n      while ((match = iRe.exec(this.javaCode)) !== null) {\r\n        names.push(match?.[1])\r\n      }\r\n      this.enumNames = names\r\n    } else {\r\n      const cRe = new RegExp(EnumParser.ENUM_RE)\r\n      const classMatch: RegExpMatchArray = cRe.exec(this.javaCode)\r\n      this.enumNames = [classMatch?.[1]] // classMatch?.groups?.enum_name;\r\n    }\r\n  }\r\n\r\n  private _getProperties() {\r\n    const properties: Record<string, EnumProperty[]> = {} \r\n    if (this.enumNames.length) { \r\n      this.enumNames.forEach((enumName, idx) => {\r\n        const startIndex = this.javaCode.indexOf(`enum ${enumName}`);\r\n        const endIndex = idx < this.enumNames.length - 1 \r\n          ? this.javaCode.indexOf(`enum ${this.enumNames[idx + 1]}`) \r\n          : this.javaCode.length\r\n        const scopeCode = this.javaCode.substring(startIndex, endIndex)\r\n        properties[enumName] = []\r\n        const pRe = new RegExp(EnumParser.PROPERTY_RE)\r\n        let propertyMatch: RegExpMatchArray\r\n        while ((propertyMatch = pRe.exec(scopeCode)) !== null) {\r\n          const p: EnumProperty = {\r\n            key: propertyMatch[1],\r\n            value: propertyMatch[2],\r\n            desc: propertyMatch[3],\r\n          }\r\n          p.type = /[\"']+/.test(p.value) ? 'String' : 'Number'\r\n          properties[enumName].push(p)\r\n        }\r\n      })\r\n    }\r\n    this.properties = properties\r\n  }\r\n\r\n  private _getJSDocWithTS() {\r\n    if (!this.enumNames.length) return '';\r\n    const results: string[] = [];\r\n    this.enumNames.forEach(enumName => {\r\n      const props = this.properties[enumName]\r\n      const enumType = getJSType(props[0].type, this.meta.outputTS)\r\n      let result = props.length\r\n        ? props.map((prop, propIdx) => {\r\n            const { desc, key, value, type } = prop\r\n            const pVlu = value ? ` = ${replaceQuote(value, `'`)}` : ``\r\n            const pDesc = desc ? `// ${replaceQuote(desc)}` : ``\r\n            return '  ' + `${key}${pVlu}, ${pDesc}`.trim()\r\n          })\r\n          .join('\\n')\r\n          .trim()\r\n        : '/*TODO no property*/'\r\n      result = `export enum ${enumName} {\\n  ${result}\\n}\\n`\r\n      results.push(formatParagraph(result))\r\n      if (EnumParser.INTERFACE_ENUMS.test(this.javaCode)) {\r\n        // TODO\r\n      } else {\r\n        global.dtsCache[enumName] = this.javaPath\r\n      }\r\n    })\r\n    return results.join('\\n\\n');\r\n  }\r\n\r\n  private _getJSDoc() {\r\n    if (!this.enumNames.length) return '';\r\n    const results: string[] = [];\r\n    this.enumNames.forEach(enumName => {\r\n      const props = this.properties[enumName]\r\n      const enumType = getJSType(props[0].type)\r\n      let result = props.length\r\n        ? props.map((prop, propIdx) => {\r\n            const { desc, key, value, type } = prop\r\n            const pVlu = value\r\n              ? `: ${replaceQuote(value, `'`)}`\r\n              : `: ${propIdx}`\r\n            const pDesc = desc ? `// ${replaceQuote(desc)}` : ``\r\n            return '  ' + `${key}${pVlu}, ${pDesc}`.trim()\r\n          })\r\n          .join('\\n')\r\n          .trim()\r\n        : '* @todo no property'\r\n      result = `export const ${enumName} = {\\n  ${result}\\n}\\n`\r\n      result = `/**\\n * @readonly\\n * @enum {${enumType}}\\n */\\n${result}`\r\n      results.push(formatParagraph(result))\r\n    })\r\n    return results.join('\\n\\n');\r\n  }\r\n\r\n  parse() {\r\n    const rtn: ParseResult = {\r\n      javaPath: this.javaPath,\r\n      result: null,\r\n    }\r\n\r\n    rtn.result = this.meta.outputTS\r\n      ? this._getJSDocWithTS()\r\n      : this._getJSDoc()\r\n\r\n    return rtn\r\n  }\r\n}\r\n\r\nexport default EnumParser\r\n","import { getJSType } from '../utils/type'\r\nimport { formatParagraph } from '../utils/text'\r\nimport type {\r\n  ParserMeta,\r\n  ParserContructor,\r\n  ParseResult,\r\n  PojoProperty,\r\n} from '../types/Parser'\r\nimport BaseParser from './BaseParser'\r\n\r\ntype TNestedStaticClassResult = {\r\n  startLine: number\r\n  endLine: number\r\n  className: string\r\n}\r\n\r\nconst PojoParser: ParserContructor = class PojoParser extends BaseParser {\r\n  static CLASS_RE = /public\\s+class\\s+(?<class_name>\\w+)/g\r\n\r\n  // TODO 通过 getter/setter 判断是否只读? springboot @data注解?\r\n  static PROPERTY_RE =\r\n    /(?:\\n(?:[^\\n\\S]|\\t)+\\/\\*{2}\\s*\\n\\s*\\*\\s+(?<desc>(?:[^@].+)?)[\\s\\S]*?)?private\\s+(?<type>[\\w<>[\\]]+)\\s+(?<name>\\w+);/g\r\n\r\n  static match(code: string) {\r\n    const { CLASS_RE, PROPERTY_RE } = PojoParser\r\n    return new RegExp(CLASS_RE).test(code) && new RegExp(PROPERTY_RE).test(code)\r\n  }\r\n\r\n  static NESTED_STATIC_CLASS_RE =\r\n    /public\\s+static\\s+class\\s+(?<class_name>\\w+).*?{/g\r\n\r\n  static matchNestedStaticClasses(\r\n    javaCode: string,\r\n  ): TNestedStaticClassResult[] {\r\n    const matches = []\r\n    let match: RegExpExecArray | null\r\n    while (\r\n      (match = PojoParser.NESTED_STATIC_CLASS_RE.exec(javaCode)) !== null\r\n    ) {\r\n      const className = match[1] // match.groups?.class_name\r\n      if (className) {\r\n        const startIndex = match.index // { 的位置\r\n        let braceCount = 1 // 初始 { 计数\r\n        let currentIndex = startIndex + 1\r\n        while (currentIndex < javaCode.length && braceCount > 0) {\r\n          const currentChar = javaCode[currentIndex]\r\n          if (currentChar === '{') {\r\n            braceCount++\r\n          } else if (currentChar === '}') {\r\n            braceCount--\r\n          }\r\n          currentIndex++\r\n        }\r\n        if (braceCount === 0) {\r\n          const endIndex = currentIndex - 1 // 最后一个 } 的位置\r\n          // 计算起始行和结束行\r\n          const startLine = javaCode.substring(0, startIndex).split('\\n').length\r\n          const endLine = javaCode.substring(0, endIndex).split('\\n').length\r\n          matches.push({ startLine, endLine, className })\r\n        }\r\n      }\r\n    }\r\n    return matches?.length ? matches : null\r\n  }\r\n\r\n  static extractSubclass(\r\n    javaCode: string,\r\n    startLine: number,\r\n    endLine: number,\r\n  ): string {\r\n    const lines = javaCode.split('\\n')\r\n    const subclassLines = lines.slice(startLine - 1, endLine)\r\n    return subclassLines.join('\\n')\r\n  }\r\n\r\n  static deleteSubclass(\r\n    javaCode: string,\r\n    startLine: number,\r\n    endLine: number,\r\n  ): string {\r\n    const lines = javaCode.split('\\n')\r\n    lines.splice(startLine - 1, endLine - startLine + 1)\r\n    return lines.join('\\n')\r\n  }\r\n\r\n  private className: string\r\n  private properties: PojoProperty[]\r\n\r\n  constructor(javaCode: string, javaPath: string, meta?: ParserMeta) {\r\n    super(javaCode, javaPath, meta)\r\n    this._getClassName()\r\n    this._getProperties()\r\n    return this\r\n  }\r\n\r\n  private _getClassName() {\r\n    const cRe = new RegExp(PojoParser.CLASS_RE)\r\n    const classMatch: RegExpMatchArray = cRe.exec(this.javaCode)\r\n    this.className = classMatch[1] // classMatch?.groups?.class_name;\r\n  }\r\n\r\n  private _getProperties() {\r\n    const properties: PojoProperty[] = []\r\n    const pRe = new RegExp(PojoParser.PROPERTY_RE)\r\n    let propertyMatch: RegExpMatchArray\r\n    while ((propertyMatch = pRe.exec(this.javaCode)) !== null) {\r\n      const p: PojoProperty = {\r\n        // ...pick(propertyMatch.groups, 'desc', 'type', 'name'),\r\n        desc: propertyMatch[1],\r\n        type: propertyMatch[2],\r\n        name: propertyMatch[3],\r\n        isOptional: !propertyMatch[0].includes('@NotNull'),\r\n      }\r\n      properties.push(p)\r\n    }\r\n    this.properties = properties\r\n  }\r\n\r\n  private _getJSDoc() {\r\n    let result = new RegExp(PojoParser.PROPERTY_RE).test(this.javaCode)\r\n      ? this.properties\r\n          .map(prop => {\r\n            const { desc, name, type, isOptional } = prop\r\n            const pName = isOptional ? ` [${name}]` : ` ${name}`\r\n            const pDesc = desc ? ` - ${desc}` : ''\r\n            return `* @property {${getJSType(type)}} ${pName}${pDesc}`.trim()\r\n          })\r\n          .join('\\n ')\r\n          .trim()\r\n      : '* @todo no property'\r\n    result = `/**\\n * @typedef {Object} ${this.className}\\n ${result}\\n*/`\r\n    return formatParagraph(result)\r\n  }\r\n\r\n  private _getJSDocWithTS() {\r\n    let result = new RegExp(PojoParser.PROPERTY_RE).test(this.javaCode)\r\n      ? this.properties\r\n          .map(prop => {\r\n            const { desc, name, type, isOptional } = prop\r\n            const pType = getJSType(type, this.meta.outputTS)\r\n            const pOptional = isOptional ? `?` : ``\r\n            const pDesc = desc ? ` // ${desc}` : ''\r\n            return `${name}${pOptional}: ${pType};${pDesc}`.trim()\r\n          })\r\n          .join('\\n ')\r\n          .trim()\r\n      : '/*TODO no property*/'\r\n    result = `export type ${this.className} = {\\n ${result}\\n}\\n`\r\n    global.dtsCache[this.className] = this.javaPath\r\n    return formatParagraph(result)\r\n  }\r\n\r\n  parse() {\r\n    const rtn: ParseResult = {\r\n      javaPath: this.javaPath,\r\n      result: null,\r\n    }\r\n\r\n    rtn.result = this.meta.outputTS ? this._getJSDocWithTS() : this._getJSDoc()\r\n\r\n    return rtn\r\n  }\r\n}\r\n\r\nexport default PojoParser\r\n","const fs = require(\"fs\");\r\n\r\nexport const readJava = (filePath: string) => {\r\n  try {\r\n    return fs.readFileSync(filePath, \"utf8\");\r\n  } catch (ex) {\r\n    console.error(\"read error:\", filePath);\r\n    return null;\r\n  }\r\n};\r\n","import type { ParseOption, ParseResult, ParserContructor } from './types/Parser'\r\nimport ServiceParser from './parsers/ServiceParser'\r\nimport EnumParser from './parsers/EnumParser'\r\nimport PojoParser from './parsers/PojoParser'\r\nimport ConstantParser from './parsers/ConstantParser'\r\nimport { readJava } from './utils/file'\r\nconst fs = require('fs')\r\nconst path = require('path')\r\n\r\nglobal.dtsCache = {}\r\n\r\n// TODO 匹配更多特征\r\n// TODO 特征放在外部配置文件中?\r\nfunction parseJava(\r\n  javaCode: string,\r\n  javaPath: string,\r\n  option?: ParseOption,\r\n): ParseResult[] | null {\r\n  let Parsers: Array<ParserContructor | null> = []\r\n  let code: string = javaCode\r\n  const results: ParseResult[] = []\r\n\r\n  // service\r\n  if (ServiceParser.match(code)) {\r\n    Parsers.push(ServiceParser)\r\n  }\r\n  // enum\r\n  else if (option?.isEnum) {\r\n    Parsers.push(\r\n      EnumParser.match(code)\r\n        ? EnumParser\r\n        : ConstantParser.match(code)\r\n        ? ConstantParser\r\n        : null,\r\n    )\r\n  }\r\n  // pojo\r\n  else if (PojoParser.match(code)) {\r\n    // @ts-ignore\r\n    const nestedStaticMatches = PojoParser?.matchNestedStaticClasses?.(code)\r\n    if (nestedStaticMatches?.length) {\r\n      for (let i = nestedStaticMatches.length - 1; i > -1; i--) {\r\n        const { startLine, endLine, className } = nestedStaticMatches[i]\r\n        // @ts-ignore\r\n        const nestedCode = PojoParser?.extractSubclass?.(\r\n          code,\r\n          startLine,\r\n          endLine,\r\n        )?.replace(/static\\s+class/, 'class')\r\n        const nestedClassPath =\r\n          javaPath.replace(/\\.java$/, '') + `${className}.java`\r\n        results.push(\r\n          new PojoParser(\r\n            nestedCode,\r\n            nestedClassPath,\r\n            option?.parserMeta,\r\n          ).parse(),\r\n        )\r\n        // @ts-ignore\r\n        code = PojoParser?.deleteSubclass?.(code, startLine, endLine)\r\n      }\r\n    }\r\n    Parsers.push(PojoParser)\r\n  }\r\n\r\n  Parsers = Parsers.filter(Boolean)\r\n  if (!Parsers.length) return null\r\n\r\n  return [\r\n    ...results,\r\n    ...Parsers.map(P => new P(code, javaPath, option?.parserMeta).parse()),\r\n  ]\r\n}\r\n\r\nfunction parseDir(dirPath: string, option?: ParseOption) {\r\n  const files = fs.readdirSync(dirPath)\r\n  return files\r\n    .reduce((acc: ParseResult[], file: File) => {\r\n      if (path.extname(file) !== '.java') return acc\r\n      const javaPath = path.join(dirPath, file)\r\n      const javaCode = readJava(javaPath)\r\n      if (!javaCode) return acc\r\n      const results = parseJava(javaCode, javaPath, option)\r\n      return results ? [...acc, ...results] : acc\r\n    }, [])\r\n    .filter(Boolean)\r\n}\r\n\r\nmodule.exports = {\r\n  parseJava,\r\n  parseDir,\r\n}\r\n"],"names":["path","require","TypeMap","boolean","Boolean","char","Character","String","Date","LocalDate","LocalDateTime","LocalTime","ZonedDateTime","OffsetDateTime","UUID","byte","Byte","short","Short","int","Integer","long","Long","float","Float","double","Double","Instant","BigDecimal","BigInteger","Optional","void","getJSType","javaType","isTypescript","arrRe","test","RegExp","exec","mapped","toLowerCase","getOrImportType","parserMeta","serviceMeta","t","outputTS","arrMatch","genericMatch","types","split","map","join","global","dtsCache","javaDir","dirname","metaKey","Object","keys","find","k","replace","_class","replaceQuote","str","replaceTo","formatParagraph","trim","DefaultParserMeta","jsDocServiceRequestInstanceName","jsDocServiceTopImport","BaseParser","javaCode","javaPath","meta","this","_extends","ServiceParser","_BaseParser","_this","call","controller","services","_getController","_getServices","_assertThisInitialized","_inheritsLoose","match","code","SERVICE_RE","CONTROLLER_RE","_proto","prototype","Error","url","name","serviceMatch","sRe","params_str","params","pRe","PARAM_RE","paramMatch","paramStr","push","param_annotation","param_type","param_name","hasDesc","desc","method","res","_renderServices","service","_this$meta","_this2","reqUrl","reduce","acc","param","pa","placeholder","includes","apiPrefix","funcName","_","p1","toUpperCase","m","jsdocParams","pt","pn","pName","mapParams","funcArgs","filter","bodyOrParams","_ref","mtd","paramsKey","data","length","_getJSDoc","cont","bind","parse","rtn","result","_wrapRegExp","EnumParser","enumNames","properties","_getEnumNames","_getProperties","PROPERTY_RE","ENUM_RE","INTERFACE_ENUMS","iRe","enum_name","names","_match","classMatch","forEach","enumName","idx","startIndex","indexOf","endIndex","scopeCode","substring","propertyMatch","p","key","value","type","_getJSDocWithTS","_this3","results","props","prop","propIdx","_this4","enumType","pDesc","PojoParser","className","_getClassName","CLASS_RE","matchNestedStaticClasses","matches","NESTED_STATIC_CLASS_RE","index","braceCount","currentIndex","currentChar","startLine","endLine","extractSubclass","slice","deleteSubclass","lines","splice","isOptional","class_name","ConstantParser","_getEnumName","fs","parseJava","option","Parsers","isEnum","nestedStaticMatches","i","_PojoParser$extractSu","_nestedStaticMatches$","nestedCode","nestedClassPath","concat","P","module","exports","parseDir","dirPath","readdirSync","file","extname","filePath","readFileSync","ex","console","error","readJava"],"mappings":"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"}
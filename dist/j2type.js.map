{"version":3,"file":"j2type.js","sources":["../src/utils/type.ts","../src/utils/text.ts","../src/utils/constants.ts","../src/parsers/BaseParser.ts","../src/parsers/ServiceParser.ts","../src/parsers/EnumParser.ts","../src/parsers/PojoParser.ts","../src/utils/file.ts","../src/index.ts"],"sourcesContent":["const TypeMap = {\n  boolean: \"Boolean\",\n  Date: \"String\",\n  char: \"String\",\n  \"char[]\": \"String\",\n  byte: \"String\",\n  short: \"Number\",\n  int: \"Number\",\n  Integer: \"Number\",\n  long: \"Number\",\n  float: \"Number\",\n  double: \"Number\"\n};\n\n// https://github.com/microsoft/TypeScript/issues/36132#issuecomment-573141594\nexport const getJSType = function getJSType(javaType: string) {\n  // const arrRe: RegExp = /(?:\\w*)List<(?<itemType>\\w+)>/g;\n  const arrRe: RegExp = /(?:\\w*)List<(\\w+)>/g;\n  if (arrRe.test(javaType)) {\n    const m = new RegExp(arrRe).exec(javaType);\n    // return `${getJSType(m.groups.itemType)}[]`;\n    return `${getJSType(m[1])}[]`;\n  }\n  return TypeMap[javaType.toLowerCase()] || javaType;\n};\n","export const replaceQuote = (str: string, replaceTo: string = \"\") =>\n  str.replace(/^\"/, replaceTo).replace(/\"$/, replaceTo);\n\nexport const formatParagraph = (str: string) =>\n  str.replace(/\\n\\s*\\n/gm, \"\\n\").trim();\n","import type {ParserMeta} from \"../types/Parser\";\n\nexport const DefaultParserMeta: ParserMeta = {\n  jsDocServiceRequestInstanceName: 'request',\n  jsDocServiceTopImport: `import request from '@/utils/request'`,\n}\n","import {DefaultParserMeta} from '../utils/constants';\nimport type {\n  IParser,\n  ParserMeta,\n  ParseType,\n  ParseResult,\n} from \"../types/Parser\";\n\nabstract class BaseParser implements IParser {\n  protected javaCode: string;\n  protected javaPath: string;\n  protected meta: ParserMeta;\n\n  constructor(\n    javaCode: string,\n    javaPath: string,\n    meta?: ParserMeta\n  ) {\n    this.javaCode = javaCode;\n    this.javaPath = javaPath;\n    this.meta = {\n      ...DefaultParserMeta,\n      ...meta\n    };\n    return this;\n  }\n\n  abstract parse(type: ParseType): ParseResult\n}\n\nexport default BaseParser;\n","import {pick} from '../utils/object'\nimport {getJSType} from '../utils/type'\nimport {formatParagraph} from '../utils/text'\nimport type {\n  ParserMeta,\n  ParserContructor,\n  ControllerType,\n  ServiceType,\n  ServiceParamType,\n  ParseType,\n  ParseResult\n} from \"../types/Parser\";\nimport BaseParser from './BaseParser';\n\nconst ServiceParser: ParserContructor = class ServiceParser extends BaseParser {\n  static CONTROLLER_RE = /@RestController\\s*\\n\\s*@RequestMapping\\(\\\"(?<url>[\\w\\/_-{}:]+?)\\\"\\)\\s*\\npublic\\s+class\\s+(?<name>\\w+?)Controller\\s+/g;\n\n  static SERVICE_RE = /(\\/\\*{2}\\n\\s+\\*\\s+(?<desc>[^@\\s]*?)\\n(?:[\\s\\S]+?))?@(?:(?<method>Get|Post|Update|Put|Delete)?)Mapping\\(\\s*value\\s*=\\s*\"(?<url>[\\w\\/_-{}:]+?)\\\".*?\\)(?:[\\s\\S]+?)public\\s+(?<res>[\\w<>_[\\](,\\s)]+?)\\s+(?<name>[\\w_-]+?)\\((?<params_str>[\\s\\S]+?)?\\)\\s*{/gi;\n\n  static PARAM_RE = /(?<param_annotation>@.*?\\s)?(?<param_type>\\w+)\\s+(?<param_name>\\w+)(?:,\\s*)?/g;\n\n  private controller: ControllerType;\n  private services: ServiceType[];\n\n  constructor(\n    javaCode: string,\n    javaPath: string,\n    meta?: ParserMeta\n  ) {\n    super(javaCode, javaPath, meta);\n    this._getController();\n    this._getServices();\n    return this;\n  }\n\n  private _getController() {\n    const match = new RegExp(ServiceParser.CONTROLLER_RE).exec(this.javaCode)\n    if (!match) throw new Error('invalid controller')\n    // https://github.com/microsoft/TypeScript/issues/36132#issuecomment-573141594\n    this.controller = {url: match[1], name: match[2]} // pick(match.groups, 'url', 'name');\n  }\n\n  private _getServices() {\n    const services: ServiceType[] = []\n    const sRe = new RegExp(ServiceParser.SERVICE_RE)\n    let serviceMatch: RegExpMatchArray;\n    while ((serviceMatch = sRe.exec(this.javaCode)) !== null) {\n      // const {params_str} = serviceMatch.groups;\n      const params_str = serviceMatch[6];\n      const params: ServiceParamType[] = []\n      const pRe = new RegExp(ServiceParser.PARAM_RE)\n      let paramMatch: RegExpMatchArray\n      const paramStr = (params_str || '').replace(/[\\n\\r]/g, '').replace(/\\s+/g, ' ')\n      while ((paramMatch = pRe.exec(paramStr)) !== null) {\n        // const p: ServiceParamType = pick(paramMatch.groups,\n        //   'param_type', 'param_name', 'param_annotation');\n        const p: ServiceParamType = {\n          param_annotation: paramMatch[1],\n          param_type: paramMatch[2],\n          param_name: paramMatch[3],\n        }\n        params.push(p);\n      }\n      const s: ServiceType = {\n        params,\n        // ...pick(serviceMatch.groups, 'desc', 'method', 'url', 'res', 'name')\n        desc: serviceMatch[1],\n        method: serviceMatch[2],\n        url: serviceMatch[3],\n        res: serviceMatch[4],\n        name: serviceMatch[5],\n      };\n      services.push(s);\n    }\n    this.services = services\n  }\n\n  private _renderServices(service: ServiceType) {\n    const url = `${this.controller.url}${service.url}`.replace(/\\/+/g, '/')\n    const reqUrl = service.params.reduce((acc, param) => {\n      const {param_name, param_annotation: pa} = param;\n      const placeholder = `{${param_name}}`\n      if (pa?.includes('PathVariable') && acc.includes(placeholder)) {\n        acc = acc.replace(placeholder, `$${placeholder}`)\n      }\n      return acc\n    }, '`' + (this.meta?.apiPrefix || '') + url + '`')\n    const funcName = url\n      .replace(/\\/{\\w+?}/g, '') // placeholder\n      .replace(/\\/(\\w)/g, (_, p1) => p1.toUpperCase())\n      .replace(/^\\w/, m => m.toLowerCase())\n    const jsdocParams = service.params.map(param => {\n      const {param_type: pt, param_name: pn, param_annotation: pa} = param\n      const isHeader = pa?.includes('RequestHeader')\n      const isOptional = !pa || !pa.includes('@NotNull')\n      const pName = isHeader ? `headers.${pn}` : pn\n      const name = isOptional ? ` [${pName}]` : ` ${pName}`\n      return `* @param {${getJSType(pt)}} ${name}`.trim()\n    }).join('\\n ').trim()\n    const mapParams = (param: ServiceParamType) => {\n      const {param_name: pn, param_annotation: pa} = param\n      const isHeader = pa?.includes('RequestHeader')\n      return isHeader ? null : pn\n    }\n    const funcArgs = service.params.map(mapParams).filter(Boolean).join(', ')\n    const bodyOrParams = service.params\n      .filter(({param_annotation: pa}) => !pa || !pa.includes('PathVariable'))\n      .map(mapParams)\n      .filter(Boolean)\n      .map(param => this.javaCode.includes('ResponseBody')\n        ? `...${param}`\n        : param\n      )\n    const mtd = service.method.toLowerCase()\n    const paramsKey = /(post|put|patch|delete)/.test(mtd) ? 'body' : 'params'\n    const data = bodyOrParams.length ? `${paramsKey}: {\n      ${bodyOrParams.join(',\\n      ')}\n    }` : ''\n\n    return `/** ${funcName}\n * @url ${url}\n * @method ${mtd.toUpperCase()}\n ${jsdocParams}\n * @return {Promise<${getJSType(service.res)}>}\\n */\\n\nexport function ${funcName} (${funcArgs}) {\n  return ${this.meta.jsDocServiceRequestInstanceName}({\n    url: ${reqUrl},\n    method: '${mtd}',\n    ${data}\n  })\n}\n  `\n  }\n\n  private _getJSDoc() {\n    const cont = formatParagraph(\n      this.services.map(this._renderServices.bind(this))\n        .join('\\n')\n        .trim()\n    )\n    return `${this.meta.jsDocServiceTopImport}\\n\\n${cont}`\n  }\n\n  // TODO ts\n  parse(type: ParseType = 'jsdoc') {\n    const rtn: ParseResult = {\n      javaPath: this.javaPath,\n      result: null\n    }\n\n    if (type === 'jsdoc') {\n      rtn.result = this._getJSDoc()\n    }\n\n    return rtn;\n  }\n}\n\nexport default ServiceParser;\n","import {pick} from '../utils/object'\nimport {getJSType} from '../utils/type'\nimport {formatParagraph, replaceQuote} from '../utils/text'\nimport type {\n  ParserMeta,\n  ParserContructor,\n  ParseType,\n  ParseResult,\n  EnumProperty\n} from \"../types/Parser\";\nimport BaseParser from './BaseParser';\n\nconst EnumParser: ParserContructor = class EnumParser extends BaseParser {\n  static ENUM_RE = /public\\s+enum\\s+(?<enum_name>\\w+)/g\n\n  static PROPERTY_RE = /(?<key>[A-Z_]+?)(?:\\((?<value>\\S+?)\\s*(?:,\\s*(?<desc>\\S+?))?\\))?[,;]/gm\n\n  private enumName: string;\n  private properties: EnumProperty[];\n\n  constructor(\n    javaCode: string,\n    javaPath: string,\n    meta?: ParserMeta\n  ) {\n    super(javaCode, javaPath, meta);\n    this._getEnumName();\n    this._getProperties();\n    return this;\n  }\n\n  private _getEnumName() {\n    const cRe = new RegExp(EnumParser.ENUM_RE)\n    const classMatch: RegExpMatchArray = cRe.exec(this.javaCode);\n    this.enumName = classMatch[1] // classMatch?.groups?.enum_name;\n  }\n\n  private _getProperties() {\n    const properties: EnumProperty[] = [];\n    const pRe = new RegExp(EnumParser.PROPERTY_RE)\n    let propertyMatch: RegExpMatchArray;\n    while ((propertyMatch = pRe.exec(this.javaCode)) !== null) {\n      // const p: EnumProperty = pick(propertyMatch.groups, 'desc', 'key', 'value')\n      const p: EnumProperty = {\n        key: propertyMatch[1],\n        value: propertyMatch[2],\n        desc: propertyMatch[3]\n      }\n      p.type = /[\"']+/.test(p.value) ? 'String' : 'Number'\n      properties.push(p)\n    }\n    this.properties = properties;\n  }\n\n  private _getJSDoc() {\n    if (!this.properties.length) return '';\n    const enumType = getJSType(this.properties[0].type);\n    let result = new RegExp(EnumParser.PROPERTY_RE).test(this.javaCode)\n      ? this.properties.map((prop, propIdx) => {\n        const {desc, key, value, type} = prop\n        const pVlu = value ? `: ${replaceQuote(value, `'`)}` : `: ${propIdx}`\n        const pDesc = desc ? `// ${replaceQuote(desc)}` : ``\n        return '  ' + `${key}${pVlu}, ${pDesc}`.trim()\n      }).join('\\n').trim()\n      : '* @todo no property'\n    result = `export const ${this.enumName} = {\\n  ${result}\\n}\\n`\n    result = `/**\\n * @readonly\\n * @enum {${enumType}}\\n */\\n${result}`\n    return formatParagraph(result);\n  }\n\n  // TODO ts\n  parse(type: ParseType = 'jsdoc') {\n    const rtn: ParseResult = {\n      javaPath: this.javaPath,\n      result: null\n    }\n\n    if (type === 'jsdoc') {\n      rtn.result = this._getJSDoc()\n    }\n\n    return rtn;\n  }\n}\n\nexport default EnumParser;\n","import {pick} from '../utils/object'\nimport {getJSType} from '../utils/type'\nimport {formatParagraph} from '../utils/text'\nimport type {\n  ParserMeta,\n  ParserContructor,\n  ParseType,\n  ParseResult,\n  PojoProperty\n} from \"../types/Parser\";\nimport BaseParser from './BaseParser';\n\nconst PojoParser: ParserContructor = class PojoParser extends BaseParser {\n  static CLASS_RE = /public\\s+class\\s+(?<class_name>\\w+)/g\n\n  // TODO 判断是否只读\n  static PROPERTY_RE = /(?:\\s*\\/\\*{2}\\s*\\n\\s*\\*\\s+(?<desc>(?:[^@].)+?)[\\s\\S]*?)?private\\s+(?<type>[\\w<>[\\]]+)\\s+(?<name>\\w+);/g\n\n  private className: string;\n  private properties: PojoProperty[];\n\n  constructor(\n    javaCode: string,\n    javaPath: string,\n    meta?: ParserMeta\n  ) {\n    super(javaCode, javaPath, meta);\n    this._getClassName();\n    this._getProperties();\n    return this;\n  }\n\n  private _getClassName() {\n    const cRe = new RegExp(PojoParser.CLASS_RE)\n    const classMatch: RegExpMatchArray = cRe.exec(this.javaCode);\n    this.className = classMatch[1] // classMatch?.groups?.class_name;\n  }\n\n  private _getProperties() {\n    const properties: PojoProperty[] = [];\n    const pRe = new RegExp(PojoParser.PROPERTY_RE)\n    let propertyMatch: RegExpMatchArray;\n    while ((propertyMatch = pRe.exec(this.javaCode)) !== null) {\n      const p: PojoProperty = {\n        // ...pick(propertyMatch.groups, 'desc', 'type', 'name'),\n        desc: propertyMatch[1],\n        type: propertyMatch[2],\n        name: propertyMatch[3],\n        isOptional: !propertyMatch[0].includes('@NotNull')\n      }\n      properties.push(p)\n    }\n    this.properties = properties;\n  }\n\n  private _getJSDoc() {\n    let result = new RegExp(PojoParser.PROPERTY_RE).test(this.javaCode)\n      ? this.properties.map(prop => {\n        const {desc, name, type, isOptional} = prop\n        const pName = isOptional ? ` [${name}]` : ` ${name}`\n        const pDesc = desc ? ` - ${desc}` : ''\n        return `* @property {${getJSType(type)}} ${pName}${pDesc}`.trim()\n      }).join('\\n ').trim()\n      : '* @todo no property'\n    result = `/**\\n * @typedef {Object} ${this.className}\\n ${result}\\n*/`\n    return formatParagraph(result);\n  }\n\n  // TODO ts\n  parse(type: ParseType = 'jsdoc') {\n    const rtn: ParseResult = {\n      javaPath: this.javaPath,\n      result: null\n    }\n\n    if (type === 'jsdoc') {\n      rtn.result = this._getJSDoc()\n    }\n\n    return rtn;\n  }\n}\n\nexport default PojoParser;\n","const fs = require(\"fs\");\n\nexport const readJava = (filePath: string) => {\n  try {\n    return fs.readFileSync(filePath, \"utf8\");\n  } catch (ex) {\n    console.error(\"read error:\", filePath);\n    return null;\n  }\n};\n","import type {ParseOption, ParseResult, ParserContructor} from \"./types/Parser\";\nimport ServiceParser from \"./parsers/ServiceParser\";\nimport EnumParser from \"./parsers/EnumParser\";\nimport PojoParser from \"./parsers/PojoParser\";\nimport {readJava} from \"./utils/file\";\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\n// TODO 匹配更多特征\n// TODO 特征放在外部配置文件中\nfunction parseJava(javaCode: string, javaPath: string, option?: ParseOption) {\n  let Parser: ParserContructor | null = null;\n  // service\n  if (option?.isService || /@RestController/.test(javaCode))\n    Parser = ServiceParser;\n  // enum\n  else if (option?.isEnum || /public\\s+enum\\s+/.test(javaCode))\n    Parser = EnumParser;\n  // pojo\n  else if (/public\\s+class\\s+/.test(javaCode)) Parser = PojoParser;\n\n  if (Parser)\n    return new Parser(\n      javaCode,\n      javaPath,\n      option?.parserMeta\n    ).parse('jsdoc');\n\n  return null;\n}\n\nfunction parseDir(dirPath: string, option?: ParseOption) {\n  const files = fs.readdirSync(dirPath);\n  return files.reduce((acc: ParseResult[], file: File) => {\n    if (path.extname(file) !== \".java\") return acc;\n    const javaPath = path.join(dirPath, file);\n    const javaCode = readJava(javaPath);\n    if (!javaCode) return acc;\n    acc.push(parseJava(javaCode, javaPath, option));\n    return acc;\n  }, []);\n}\n\nmodule.exports = {\n  parseJava,\n  parseDir,\n};\n"],"names":["TypeMap","boolean","Date","char","byte","short","int","Integer","long","float","double","getJSType","javaType","arrRe","test","RegExp","exec","toLowerCase","replaceQuote","str","replaceTo","replace","formatParagraph","trim","DefaultParserMeta","jsDocServiceRequestInstanceName","jsDocServiceTopImport","BaseParser","javaCode","javaPath","meta","this","_extends","ServiceParser","_class","_BaseParser","_this","call","controller","services","_getController","_getServices","_assertThisInitialized","_inheritsLoose","_proto","prototype","match","CONTROLLER_RE","Error","url","name","serviceMatch","sRe","SERVICE_RE","params_str","params","pRe","PARAM_RE","paramMatch","paramStr","push","param_annotation","param_type","param_name","desc","method","res","_renderServices","service","_this$meta","_this2","reqUrl","reduce","acc","param","pa","placeholder","includes","apiPrefix","funcName","_","p1","toUpperCase","m","jsdocParams","map","pt","pn","pName","join","mapParams","funcArgs","filter","Boolean","bodyOrParams","_ref","mtd","paramsKey","data","length","_getJSDoc","cont","bind","parse","type","rtn","result","_wrapRegExp","EnumParser","enumName","properties","_getEnumName","_getProperties","classMatch","ENUM_RE","propertyMatch","PROPERTY_RE","p","key","value","enumType","prop","propIdx","enum_name","PojoParser","className","_getClassName","CLASS_RE","isOptional","pDesc","class_name","fs","require","path","parseJava","option","Parser","isService","isEnum","parserMeta","module","exports","parseDir","dirPath","readdirSync","file","extname","filePath","readFileSync","ex","console","error","readJava"],"mappings":"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"}
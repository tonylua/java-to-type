{"version":3,"file":"j2type.js","sources":["../src/utils/type.ts","../src/utils/text.ts","../src/parsers/ServiceParser.ts","../src/parsers/EnumParser.ts","../src/parsers/PojoParser.ts","../src/parsers/ConstantParser.ts","../src/utils/constants.ts","../src/parsers/BaseParser.ts","../src/utils/file.ts","../src/index.ts"],"sourcesContent":["import type { ParserMeta } from '../types/Parser'\nconst path = require('path')\n\nconst TypeMap = {\n  'boolean': 'Boolean',\n  'Date': 'String',\n  'char': 'String',\n  'char[]': 'String',\n  'String': 'String',\n  'byte': 'String',\n  'short': 'Number',\n  'int': 'Number',\n  'Integer': 'Number',\n  'long': 'Number',\n  'float': 'Number',\n  'double': 'Number',\n}\n\n// https://github.com/microsoft/TypeScript/issues/36132#issuecomment-573141594\nexport const getJSType = function getJSType(\n  javaType: string,\n  isTypescript = false,\n) {\n  // const arrRe: RegExp = /(?:\\w*)List<(?<itemType>\\w+)>/g;\n  const arrRe: RegExp = /(?:\\w*)List<(\\w+)>/g\n  if (arrRe.test(javaType)) {\n    const m = new RegExp(arrRe).exec(javaType)\n    // return `${getJSType(m.groups.itemType)}[]`;\n    return `${getJSType(m[1], isTypescript)}[]`\n  }\n  const mapped = TypeMap[javaType.toLowerCase()]\n  if (mapped) return isTypescript ? mapped.toLowerCase() : mapped\n  return javaType\n}\n\nexport function getOrImportType(javaType: string, parserMeta: ParserMeta) {\n  const serviceMeta = parserMeta?.serviceMeta\n  let t = getJSType(javaType, parserMeta?.outputTS)\n\n  const arrMatch = /^(.*?)(\\[\\])+$/.exec(t)\n  if (arrMatch) return getOrImportType(arrMatch[1], serviceMeta) + arrMatch[2]\n\n  const genericMatch = /^(.*?)<(.*?)>$/.exec(t)\n  if (genericMatch) {\n    const types = genericMatch[2]\n      .split(/\\s*\\,\\s*/)\n      .map(t => getOrImportType(t, serviceMeta))\n      .join(', ')\n    return `${genericMatch[1]}<${types}>`\n  }\n\n  if (t in global.dtsCache) {\n    const javaDir = path.dirname(global.dtsCache[t])\n    const metaKey = Object.keys(serviceMeta).find(k => k === javaDir)\n    if (metaKey) {\n      const dtsPath = serviceMeta[metaKey].replace(/\\.d\\.ts$/, '')\n      t = `import('${dtsPath}').${t}`\n    }\n  }\n\n  return t\n}\n","export const replaceQuote = (str: string, replaceTo: string = \"\") =>\n  str.replace(/^\"/, replaceTo).replace(/\"$/, replaceTo);\n\nexport const formatParagraph = (str: string) =>\n  str.replace(/\\n\\s*\\n/gm, \"\\n\").trim();\n","import { getOrImportType } from '../utils/type'\nimport { formatParagraph } from '../utils/text'\nimport type {\n  ParserMeta,\n  ParserContructor,\n  ControllerType,\n  ServiceType,\n  ServiceParamType,\n  ParseType,\n  ParseResult,\n} from '../types/Parser'\nimport BaseParser from './BaseParser'\n\nconst ServiceParser: ParserContructor = class ServiceParser extends BaseParser {\n  static CONTROLLER_RE =\n    /@RestController\\s*\\n\\s*@RequestMapping\\(\\\"(?<url>[\\w\\/_-{}:]+?)\\\"\\)[\\s\\S]*?\\npublic\\s+class\\s+(?<name>\\w+?)Controller\\s+/g\n\n  static SERVICE_RE =\n    /(\\/\\*{2}\\n\\s+\\*\\s+(?<desc>[^@\\s]*?)\\n(?:[\\s\\S]+?))?@(?:(?<method>Get|Post|Update|Put|Delete)?)Mapping\\(\\s*(?:value\\s*=\\s*)?\"(?<url>[\\w\\/_-{}:]+?)\\\".*?\\)(?:[\\s\\S]+?)public\\s+(?<res>[\\w<>_[\\](,\\s)]+?)\\s+(?<name>[\\w_-]+?)\\((?<params_str>[\\s\\S]*)\\)?\\s*{/gi\n\n  static PARAM_RE =\n    /(?<param_annotation>@.*?\\s)?(?<param_type>[\\w<>_[\\](,\\s)]+?)\\s+(?<param_name>\\w+)(?:,\\s*)?/g\n\n  private controller: ControllerType\n  private services: ServiceType[]\n\n  constructor(javaCode: string, javaPath: string, meta?: ParserMeta) {\n    super(javaCode, javaPath, meta)\n    this._getController()\n    this._getServices()\n    return this\n  }\n\n  private _getController() {\n    const match = new RegExp(ServiceParser.CONTROLLER_RE).exec(this.javaCode)\n    if (!match) throw new Error('invalid controller')\n    // https://github.com/microsoft/TypeScript/issues/36132#issuecomment-573141594\n    this.controller = { url: match[1], name: match[2] } // pick(match.groups, 'url', 'name');\n  }\n\n  private _getServices() {\n    const services: ServiceType[] = []\n    const sRe = new RegExp(ServiceParser.SERVICE_RE)\n    let serviceMatch: RegExpMatchArray\n    while ((serviceMatch = sRe.exec(this.javaCode)) !== null) {\n      // const {params_str} = serviceMatch.groups;\n      // console.log(Array.from(serviceMatch))\n      const params_str = serviceMatch[7]\n      const params: ServiceParamType[] = []\n      const pRe = new RegExp(ServiceParser.PARAM_RE)\n      let paramMatch: RegExpMatchArray\n      const paramStr = (params_str || '')\n        .replace(/[\\n\\r]/g, '')\n        .replace(/\\s+/g, ' ')\n      // console.log(333, params_str, paramStr)\n      while ((paramMatch = pRe.exec(paramStr)) !== null) {\n        // const p: ServiceParamType = pick(paramMatch.groups,\n        //   'param_type', 'param_name', 'param_annotation');\n        const p: ServiceParamType = {\n          param_annotation: paramMatch[1],\n          param_type: paramMatch[2],\n          param_name: paramMatch[3],\n        }\n        params.push(p)\n      }\n      const hasDesc = /\\/\\*\\*/.test(serviceMatch[1])\n      const s: ServiceType = {\n        params,\n        // ...pick(serviceMatch.groups, 'desc', 'method', 'url', 'res', 'name')\n        desc: hasDesc ? serviceMatch[2] : '',\n        method: serviceMatch[3],\n        url: serviceMatch[4],\n        res: serviceMatch[5],\n        name: serviceMatch[6],\n      }\n      // console.log(Array.prototype.slice.call(serviceMatch, 0, 7), s)\n      services.push(s)\n    }\n    this.services = services\n  }\n\n  private _renderServices(service: ServiceType) {\n    const url = `${this.controller.url}${service.url}`.replace(/\\/+/g, '/')\n    const reqUrl = service.params.reduce(\n      (acc, param) => {\n        const { param_name, param_annotation: pa } = param\n        const placeholder = `{${param_name}}`\n        if (pa?.includes('PathVariable') && acc.includes(placeholder)) {\n          acc = acc.replace(placeholder, `$${placeholder}`)\n        }\n        return acc\n      },\n      '`' + (this.meta?.apiPrefix || '') + url + '`',\n    )\n    const funcName = url\n      .replace(/\\/{\\w+?}/g, '') // placeholder\n      .replace(/\\/(\\w)/g, (_, p1) => p1.toUpperCase())\n      .replace(/^\\w/, m => m.toLowerCase())\n    const jsdocParams = service.params\n      .map(param => {\n        const { param_type: pt, param_name: pn, param_annotation: pa } = param\n        const isHeader = pa?.includes('RequestHeader')\n        const isOptional = !pa || !pa.includes('@NotNull')\n        const pName = isHeader ? `headers.${pn}` : pn\n        const name = isOptional ? ` [${pName}]` : ` ${pName}`\n        return `* @param {${getOrImportType(pt, this.meta)}} ${name}`.trim()\n      })\n      .join('\\n ')\n      .trim()\n    const mapParams = (param: ServiceParamType) => {\n      const { param_name: pn, param_annotation: pa } = param\n      const isHeader = pa?.includes('RequestHeader')\n      return isHeader ? null : pn\n    }\n    const funcArgs = service.params.map(mapParams).filter(Boolean).join(', ')\n    const bodyOrParams = service.params\n      .filter(({ param_annotation: pa }) => !pa || !pa.includes('PathVariable'))\n      .map(mapParams)\n      .filter(Boolean)\n      .map(param =>\n        this.javaCode.includes('ResponseBody') ? `...${param}` : param,\n      )\n    // console.log(service.name, service.method)\n\n    let mtd = service.method.toLowerCase()\n    const paramsKey = /(post|put|patch|delete)/.test(mtd) ? 'body' : 'params'\n    const data = bodyOrParams.length\n      ? `${paramsKey}: {\n      ${bodyOrParams.join(',\\n      ')}\n    }`\n      : ''\n\n    return `/** ${service.desc} ${funcName}\n * @url ${url}\n * @method ${mtd.toUpperCase()}\n ${jsdocParams}\n * @return {Promise<${getOrImportType(service.res, this.meta)}>}\\n */\\n\nexport function ${funcName} (${funcArgs}) {\n  return ${this.meta.jsDocServiceRequestInstanceName}({\n    url: ${reqUrl},\n    method: '${mtd}',\n    ${data}\n  })\n}\n  `\n  }\n\n  private _getJSDoc() {\n    const cont = formatParagraph(\n      this.services.map(this._renderServices.bind(this)).join('\\n').trim(),\n    )\n    return `${this.meta.jsDocServiceTopImport}\\n\\n${cont}`\n  }\n\n  // TODO ts\n  parse(type: ParseType = 'jsdoc') {\n    const rtn: ParseResult = {\n      javaPath: this.javaPath,\n      result: null,\n    }\n\n    if (type === 'jsdoc') {\n      rtn.result = this._getJSDoc()\n    }\n\n    return rtn\n  }\n}\n\nexport default ServiceParser\n","import { getJSType } from '../utils/type'\nimport { formatParagraph, replaceQuote } from '../utils/text'\nimport type {\n  ParserMeta,\n  ParserContructor,\n  ParseType,\n  ParseResult,\n  EnumProperty,\n} from '../types/Parser'\nimport BaseParser from './BaseParser'\n\nconst EnumParser: ParserContructor = class EnumParser extends BaseParser {\n  static ENUM_RE = /public\\s+enum\\s+(?<enum_name>\\w+)/g\n\n  static PROPERTY_RE =\n    /(?<key>[A-Z_]+?)(?:\\((?<value>\\S+?)\\s*(?:,\\s*(?<desc>\\S+?))?\\))?[,;]/gm\n\n  static toString() {\n    return 'EnumParser'\n  }\n\n  private enumName: string\n  private properties: EnumProperty[]\n\n  constructor(javaCode: string, javaPath: string, meta?: ParserMeta) {\n    super(javaCode, javaPath, meta)\n    this._getEnumName()\n    this._getProperties()\n    return this\n  }\n\n  private _getEnumName() {\n    const cRe = new RegExp(EnumParser.ENUM_RE)\n    const classMatch: RegExpMatchArray = cRe.exec(this.javaCode)\n    this.enumName = classMatch?.[1] // classMatch?.groups?.enum_name;\n  }\n\n  private _getProperties() {\n    const properties: EnumProperty[] = []\n    const pRe = new RegExp(EnumParser.PROPERTY_RE)\n    let propertyMatch: RegExpMatchArray\n    while ((propertyMatch = pRe.exec(this.javaCode)) !== null) {\n      // const p: EnumProperty = pick(propertyMatch.groups, 'desc', 'key', 'value')\n      const p: EnumProperty = {\n        key: propertyMatch[1],\n        value: propertyMatch[2],\n        desc: propertyMatch[3],\n      }\n      p.type = /[\"']+/.test(p.value) ? 'String' : 'Number'\n      properties.push(p)\n    }\n    this.properties = properties\n  }\n\n  private _getJSDocWithTS() {\n    if (!this.properties.length) return ''\n    const enumType = getJSType(this.properties[0].type, this.meta.outputTS)\n    let result = new RegExp(EnumParser.PROPERTY_RE).test(this.javaCode)\n      ? this.properties\n          .map((prop, propIdx) => {\n            const { desc, key, value, type } = prop\n            const pVlu = value ? ` = ${replaceQuote(value, `'`)}` : ``\n            const pDesc = desc ? `// ${replaceQuote(desc)}` : ``\n            return '  ' + `${key}${pVlu}, ${pDesc}`.trim()\n          })\n          .join('\\n')\n          .trim()\n      : '/*TODO no property*/'\n    result = `export enum ${this.enumName} {\\n  ${result}\\n}\\n`\n    global.dtsCache[this.enumName] = this.javaPath\n    return formatParagraph(result)\n  }\n\n  private _getJSDoc() {\n    if (!this.properties.length) return ''\n    const enumType = getJSType(this.properties[0].type)\n    let result = new RegExp(EnumParser.PROPERTY_RE).test(this.javaCode)\n      ? this.properties\n          .map((prop, propIdx) => {\n            const { desc, key, value, type } = prop\n            const pVlu = value\n              ? `: ${replaceQuote(value, `'`)}`\n              : `: ${propIdx}`\n            const pDesc = desc ? `// ${replaceQuote(desc)}` : ``\n            return '  ' + `${key}${pVlu}, ${pDesc}`.trim()\n          })\n          .join('\\n')\n          .trim()\n      : '* @todo no property'\n    result = `export const ${this.enumName} = {\\n  ${result}\\n}\\n`\n    result = `/**\\n * @readonly\\n * @enum {${enumType}}\\n */\\n${result}`\n    return formatParagraph(result)\n  }\n\n  // TODO ts\n  parse(type: ParseType = 'jsdoc') {\n    const rtn: ParseResult = {\n      javaPath: this.javaPath,\n      result: null,\n    }\n\n    if (type === 'jsdoc') {\n      rtn.result = this.meta.outputTS\n        ? this._getJSDocWithTS()\n        : this._getJSDoc()\n    }\n\n    return rtn\n  }\n}\n\nexport default EnumParser\n","import { getJSType } from '../utils/type'\nimport { formatParagraph } from '../utils/text'\nimport type {\n  ParserMeta,\n  ParserContructor,\n  ParseType,\n  ParseResult,\n  PojoProperty,\n} from '../types/Parser'\nimport BaseParser from './BaseParser'\n\nconst PojoParser: ParserContructor = class PojoParser extends BaseParser {\n  static CLASS_RE = /public\\s+class\\s+(?<class_name>\\w+)/g\n\n  // TODO 判断是否只读\n  static PROPERTY_RE =\n    /(?:\\s*\\/\\*{2}\\s*\\n\\s*\\*\\s+(?<desc>(?:[^@].)+?)[\\s\\S]*?)?private\\s+(?<type>[\\w<>[\\]]+)\\s+(?<name>\\w+);/g\n\n  private className: string\n  private properties: PojoProperty[]\n\n  constructor(javaCode: string, javaPath: string, meta?: ParserMeta) {\n    super(javaCode, javaPath, meta)\n    this._getClassName()\n    this._getProperties()\n    return this\n  }\n\n  private _getClassName() {\n    const cRe = new RegExp(PojoParser.CLASS_RE)\n    const classMatch: RegExpMatchArray = cRe.exec(this.javaCode)\n    this.className = classMatch[1] // classMatch?.groups?.class_name;\n  }\n\n  private _getProperties() {\n    const properties: PojoProperty[] = []\n    const pRe = new RegExp(PojoParser.PROPERTY_RE)\n    let propertyMatch: RegExpMatchArray\n    while ((propertyMatch = pRe.exec(this.javaCode)) !== null) {\n      const p: PojoProperty = {\n        // ...pick(propertyMatch.groups, 'desc', 'type', 'name'),\n        desc: propertyMatch[1],\n        type: propertyMatch[2],\n        name: propertyMatch[3],\n        isOptional: !propertyMatch[0].includes('@NotNull'),\n      }\n      properties.push(p)\n    }\n    this.properties = properties\n  }\n\n  private _getJSDoc() {\n    let result = new RegExp(PojoParser.PROPERTY_RE).test(this.javaCode)\n      ? this.properties\n          .map(prop => {\n            const { desc, name, type, isOptional } = prop\n            const pName = isOptional ? ` [${name}]` : ` ${name}`\n            const pDesc = desc ? ` - ${desc}` : ''\n            return `* @property {${getJSType(type)}} ${pName}${pDesc}`.trim()\n          })\n          .join('\\n ')\n          .trim()\n      : '* @todo no property'\n    result = `/**\\n * @typedef {Object} ${this.className}\\n ${result}\\n*/`\n    return formatParagraph(result)\n  }\n\n  private _getJSDocWithTS() {\n    let result = new RegExp(PojoParser.PROPERTY_RE).test(this.javaCode)\n      ? this.properties\n          .map(prop => {\n            const { desc, name, type, isOptional } = prop\n            const pType = getJSType(type, this.meta.outputTS)\n            const pOptional = isOptional ? `?` : ``\n            const pDesc = desc ? ` // ${desc}` : ''\n            return `${name}${pOptional}: ${pType};${pDesc}`.trim()\n          })\n          .join('\\n ')\n          .trim()\n      : '/*TODO no property*/'\n    result = `export type ${this.className} = {\\n ${result}\\n}\\n`\n    global.dtsCache[this.className] = this.javaPath\n    return formatParagraph(result)\n  }\n\n  // TODO ts\n  parse(type: ParseType = 'jsdoc') {\n    const rtn: ParseResult = {\n      javaPath: this.javaPath,\n      result: null,\n    }\n\n    if (type === 'jsdoc') {\n      rtn.result = this.meta.outputTS\n        ? this._getJSDocWithTS()\n        : this._getJSDoc()\n    }\n\n    return rtn\n  }\n}\n\nexport default PojoParser\n","import { getJSType } from '../utils/type'\nimport { formatParagraph, replaceQuote } from '../utils/text'\nimport type {\n  ParserMeta,\n  ParserContructor,\n  ParseType,\n  ParseResult,\n  EnumProperty,\n} from '../types/Parser'\nimport BaseParser from './BaseParser'\n\n// eslint-disable-next-line max-len\nconst ConstantParser: ParserContructor = class ConstantParser extends BaseParser {\n  static ENUM_RE = /public\\s+class\\s+(?<enum_name>\\w+)/g\n\n  static PROPERTY_RE =\n    /(?:\\s*\\/\\*{2}\\n\\s*\\*\\s+([^@\\s]+?)\\n[\\s\\S]+?)?public\\sstatic\\sfinal\\s([\\w<>[\\]]+)\\s+([\\w_]+)\\s*=\\s*((\"|[^\\s;$])+);?/g\n\n  static toString() {\n    return 'ConstantParser'\n  }\n\n  private enumName: string\n  private properties: EnumProperty[]\n\n  constructor(javaCode: string, javaPath: string, meta?: ParserMeta) {\n    super(javaCode, javaPath, meta)\n    this._getEnumName()\n    this._getProperties()\n    return this\n  }\n\n  private _getEnumName() {\n    const cRe = new RegExp(ConstantParser.ENUM_RE)\n    const classMatch: RegExpMatchArray = cRe.exec(this.javaCode)\n    this.enumName = classMatch[1] // classMatch?.groups?.enum_name;\n  }\n\n  private _getProperties() {\n    const properties: EnumProperty[] = []\n    const pRe = new RegExp(ConstantParser.PROPERTY_RE)\n    let propertyMatch: RegExpMatchArray\n    while ((propertyMatch = pRe.exec(this.javaCode)) !== null) {\n      const p: EnumProperty = {\n        desc: propertyMatch[1],\n        type: propertyMatch[2],\n        key: propertyMatch[3],\n        value: propertyMatch[4],\n      }\n      properties.push(p)\n    }\n    this.properties = properties\n  }\n\n  private _getJSDocWithTS() {\n    if (!this.properties.length) return ''\n    const enumType = getJSType(this.properties[0].type, this.meta.outputTS)\n    let result = new RegExp(ConstantParser.PROPERTY_RE).test(this.javaCode)\n      ? this.properties\n          .map((prop, propIdx) => {\n            const { desc, key, value } = prop\n            const pVlu = value ? ` = ${replaceQuote(value, `'`)}` : ``\n            const pDesc = desc ? `// ${replaceQuote(desc)}` : ``\n            return '  ' + `${key}${pVlu}, ${pDesc}`.trim()\n          })\n          .join('\\n')\n          .trim()\n      : '/*TODO no property*/'\n    result = `export enum ${this.enumName} {\\n  ${result}\\n}\\n`\n    global.dtsCache[this.enumName] = this.javaPath\n    return formatParagraph(result)\n  }\n\n  private _getJSDoc() {\n    if (!this.properties.length) return ''\n    const enumType = getJSType(this.properties[0].type)\n    let result = new RegExp(ConstantParser.PROPERTY_RE).test(this.javaCode)\n      ? this.properties\n          .map((prop, propIdx) => {\n            const { desc, key, value } = prop\n            const pVlu = value\n              ? `: ${replaceQuote(value, `'`)}`\n              : `: ${propIdx}`\n            const pDesc = desc ? `// ${replaceQuote(desc)}` : ``\n            return '  ' + `${key}${pVlu}, ${pDesc}`.trim()\n          })\n          .join('\\n')\n          .trim()\n      : '* @todo no property'\n    result = `export const ${this.enumName} = {\\n  ${result}\\n}\\n`\n    result = `/**\\n * @readonly\\n * @enum {${enumType}}\\n */\\n${result}`\n    return formatParagraph(result)\n  }\n\n  // TODO ts\n  parse(type: ParseType = 'jsdoc') {\n    const rtn: ParseResult = {\n      javaPath: this.javaPath,\n      result: null,\n    }\n\n    if (type === 'jsdoc') {\n      rtn.result = this.meta.outputTS\n        ? this._getJSDocWithTS()\n        : this._getJSDoc()\n    }\n\n    return rtn\n  }\n}\n\nexport default ConstantParser\n","import type {ParserMeta} from \"../types/Parser\";\n\nexport const DefaultParserMeta: ParserMeta = {\n  jsDocServiceRequestInstanceName: 'request',\n  jsDocServiceTopImport: `import request from '@/utils/request'`,\n}\n","import {DefaultParserMeta} from '../utils/constants';\nimport type {\n  IParser,\n  ParserMeta,\n  ParseType,\n  ParseResult,\n} from \"../types/Parser\";\n\nabstract class BaseParser implements IParser {\n  protected javaCode: string;\n  protected javaPath: string;\n  protected meta: ParserMeta;\n\n  constructor(\n    javaCode: string,\n    javaPath: string,\n    meta?: ParserMeta\n  ) {\n    this.javaCode = javaCode;\n    this.javaPath = javaPath;\n    this.meta = {\n      ...DefaultParserMeta,\n      ...meta\n    };\n    return this;\n  }\n\n  abstract parse(type: ParseType): ParseResult\n}\n\nexport default BaseParser;\n","const fs = require(\"fs\");\n\nexport const readJava = (filePath: string) => {\n  try {\n    return fs.readFileSync(filePath, \"utf8\");\n  } catch (ex) {\n    console.error(\"read error:\", filePath);\n    return null;\n  }\n};\n","import type { ParseOption, ParseResult, ParserContructor } from './types/Parser'\nimport ServiceParser from './parsers/ServiceParser'\nimport EnumParser from './parsers/EnumParser'\nimport PojoParser from './parsers/PojoParser'\nimport ConstantParser from './parsers/ConstantParser'\nimport { readJava } from './utils/file'\nconst fs = require('fs')\nconst path = require('path')\n\nglobal.dtsCache = {}\n\n// TODO 匹配更多特征\n// TODO 特征放在外部配置文件中\n// TODO 暴露所有正则直接匹配\nfunction parseJava(javaCode: string, javaPath: string, option?: ParseOption) {\n  let Parser: ParserContructor | null = null\n  // service\n  if (option?.isService || /@RestController/.test(javaCode))\n    Parser = ServiceParser\n  // enum\n  else if (option?.isEnum) {\n    if (/public\\s+enum\\s+/.test(javaCode)) Parser = EnumParser\n    else if (ConstantParser['PROPERTY_RE'].test(javaCode))\n      Parser = ConstantParser\n  }\n  // pojo\n  else if (/public\\s+class\\s+/.test(javaCode)) Parser = PojoParser\n\n  if (Parser)\n    return new Parser(javaCode, javaPath, option?.parserMeta).parse('jsdoc')\n\n  return null\n}\n\nfunction parseDir(dirPath: string, option?: ParseOption) {\n  const files = fs.readdirSync(dirPath)\n  return files.reduce((acc: ParseResult[], file: File) => {\n    if (path.extname(file) !== '.java') return acc\n    const javaPath = path.join(dirPath, file)\n    const javaCode = readJava(javaPath)\n    if (!javaCode) return acc\n    acc.push(parseJava(javaCode, javaPath, option))\n    return acc\n  }, [])\n}\n\nmodule.exports = {\n  parseJava,\n  parseDir,\n}\n"],"names":["path","require","TypeMap","boolean","Date","char","String","byte","short","int","Integer","long","float","double","getJSType","javaType","isTypescript","arrRe","test","RegExp","exec","mapped","toLowerCase","getOrImportType","parserMeta","serviceMeta","t","outputTS","arrMatch","genericMatch","types","split","map","join","global","dtsCache","javaDir","dirname","metaKey","Object","keys","find","k","replace","_class","replaceQuote","str","replaceTo","formatParagraph","trim","DefaultParserMeta","jsDocServiceRequestInstanceName","jsDocServiceTopImport","BaseParser","javaCode","javaPath","meta","this","_extends","ServiceParser","_BaseParser","_this","call","controller","services","_getController","_getServices","_assertThisInitialized","_inheritsLoose","_proto","prototype","match","CONTROLLER_RE","Error","url","name","serviceMatch","sRe","SERVICE_RE","params_str","params","pRe","PARAM_RE","paramMatch","paramStr","push","param_annotation","param_type","param_name","hasDesc","desc","method","res","_renderServices","service","_this$meta","_this2","reqUrl","reduce","acc","param","pa","placeholder","includes","apiPrefix","funcName","_","p1","toUpperCase","m","jsdocParams","pt","pn","pName","mapParams","funcArgs","filter","Boolean","bodyOrParams","_ref","mtd","paramsKey","data","length","_getJSDoc","cont","bind","parse","type","rtn","result","_wrapRegExp","EnumParser","enumName","properties","_getEnumName","_getProperties","toString","classMatch","ENUM_RE","propertyMatch","PROPERTY_RE","p","key","value","_getJSDocWithTS","prop","propIdx","enumType","enum_name","PojoParser","className","_getClassName","CLASS_RE","isOptional","pDesc","pType","class_name","ConstantParser","fs","parseJava","option","Parser","isService","isEnum","module","exports","parseDir","dirPath","readdirSync","file","extname","filePath","readFileSync","ex","console","error","readJava"],"mappings":"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"}